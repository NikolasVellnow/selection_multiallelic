function [cost] = CostSparseFn(w, X, gens)
% Calculates the cost using a squared euclidean norm for a "sparse"
% trajectory
% Input X is a trajectory (eg from data) and is of size n*(T+1), where the
% values do not come from consecutive generations but there can be "gaps"
% in the trajectory during which no data is available
% Input gens is a vector of generations for which we have the corresponding
% data in X. Length of X and gens have to match.
% v=[0;w] is the column vector that parameterises the A fitness matrix
% w is of size n(n+1)/2-1.

% Check input arguments
if size(X,2) ~= size(gens,2)
    error("Vectors for frequency trajectory and generations have to be the same length");
end

T=size(X,2)-1;
v=[0;w];                % Always have first element of v zero
A=SMatVec(v);           % The A matrix generated by v.
    
n = size(X,1);
Y_T = NaN(n, T);        % Array of predicted freqs for "record-keeping"; not strictly needed for function to work


S=0;                    % initialize running sum
% iterate over available data points of trajectory
for t=1:T
    x=X(:,t);
    % Initialization
    if t == 1
        Y_T(:,1) = x;
        Y_t = x;
    end

    delta_T = gens(t+1)-gens(t);    % No. steps "missing" between T_i & T_i+1
    
    %iterate over "missing" steps
    for s=1:delta_T
        y = Y_t;
        V=diag(y)-y*y';             % Predicted V for (in-between-) generation
        D=V*A*y/(1+y'*A*y);         % Predicted D for (in-between-) generation
        Y_t = Y_t + D;              % Calculate Y(t) for next (in-between-) generation
    end
    
    % Calculate contribution to cost
    Y_T(:,t+1) = Y_t;
    current_diff = Y_T(:,t+1) - X(:,t+1);
    current_norm=norm(current_diff);
    S=S+current_norm^2;

    % Reset Y with value from X
    Y_t = X(:,t+1);

end

cost = S;

end